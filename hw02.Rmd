
---
title: "STAT340 HW2: Monte Carlo & Testing"
author: Ryan Cope
date: 3/1/21
output: html_document
---
<style>
table{width:50%!important;margin-left:auto!important;margin-right:auto!important;}
/*ol[style*="decimal"]>li{margin-top:40px!important;}*/
</style>

```{r setup, include=FALSE}
# check packages installed
if(!require(pacman)) install.packages("pacman")
pacman::p_load(ggplot2)

knitr::opts_chunk$set(tidy=FALSE,strip.white=FALSE,fig.align="center",comment=" #")
options(width=100)
```

<br/>

## Instructions

Complete the exercises, update the "author" and "date" fields in the header, knit it, and submit **both the HTML and RMD** files to Canvas. Due date: **Mar 4, 2022 at 11:59pm**.

---

## Exercise 1 (20 points): Generalized [birthday problem](https://en.wikipedia.org/wiki/Birthday_problem)

The birthday problem asks for the probability that in a group of $n$ people, at least 2 people will share the same birthday. This is easy to solve, and the solution is easily found online.

We can generalize this to a more difficult problem and solve it using a Monte Carlo approach: in $n$ people, what is the probability that at least $k$ people have the same birthday?

Write a function `birthday(n,k,i)` that returns a probability estimate given 3 arguments:

 - $n$ is the number of people in your sample
    - for example, if `n=50` is used, we are asking "in 50 people, what is the probability that..."
 - $k$ is minimum number of people that must share a birthday
    - for example if `k=4` is used, we asking "...what is the probability that at least 4 people share the same birthday?
 - $i$ is the number of iterations to run (default 1000)
    - for example, if `i=1000` is used, your function should run 1000 simulations

**Notes**:

 - You may assume there are 365 possible dates (no leap years)
 - You may assume birthdays are uniformly distributed across the calendar
    - this is actually not true, see [this](https://www.panix.com/~murphy/bday.html), or [this](https://fivethirtyeight.com/features/lots-of-parents-dont-want-their-kids-to-be-born-on-leap-day/)
 - You may assume the people are sampled [i.i.d](https://en.wikipedia.org/wiki/Independent_and_identically_distributed_random_variables)

**Hints**:

 1. There's no need to use actual dates in the simulation process. Numbers can represent dates and are easier to generate and manipulate in `R`. In particular, we recommend using the `sample()` function with the `x`, `size`, and `replace` arguments set appropriately. See the help page `?sample` for details.
 2. Given a vector of numbers, you can easily find duplicates by using the `table()` function. This will produce a named vector showing how many of each value there are. For example, running `table(c(1,3,5,5,7,9,9,9))` will show you there is one 1, one 3, two 5s, one 7, and three 9s.
 3. In your function, you will need to use a `for` loop to repeat the simulation `i` times. You will also need a variable outside your `for` loop to keep track of how many simulations satisfy that \# of birthdays $\geq k$.
 4. If your function is running correctly, then `birthday(n=23, k=2)`, `birthday(n=87, k=3)` and `birthday(n=188, k=4)` should all be approximately $50\%$.
 5. If your function is very slow, consider using the [`Table` function](https://rdrr.io/cran/Rfast/man/Table.html) from the Rfast package, which is 4-5 times faster than the normal `table()` function.

```{r}
# complete the function
# note i=1000 sets the default value of i to be 1000
birthday = function(n,k,i=1000){
  sims_satisfied = 0
  dates = 1:365
  
  #run for i simulations
  for(sim in 1:i){
    bdays = sample(x=dates, size=n, replace=TRUE) #sample of n birthdays
    max_bdays = max(unname(table(bdays))) #highest number of shared birthdays
    
    if(max_bdays >= k){
      sims_satisfied = sims_satisfied + 1
    }
  }
  
  #return proportion of satisfied sims given i iterations
  return(sims_satisfied/i)
}
```

This class currently has 162 enrolled students. What is the approximate probability that at least $4$ students have the same birthdays?

```{r}
birthday(n=162, k=4)
```

---

## Exercise 2 (15 points): Simulate RV

$X$ is a random variable defined between $-\frac\pi2$ and $\frac\pi2$ by the probability density function $f(x)=\frac12\cos(x)$. Note this means the cumulative distribution function is $$F(x)=\int_{-\frac\pi2}^xf(x)dx=\frac12(\sin(x)+1)$$ Write a function `rx(n)` to sample from this random variable, where `n` is the size of the sample to be drawn. Then, use your function to draw a sample of 1000 and plot a histogram of the output.

**Hint:** Remember the inverse function of $\sin(x)$ is $\arcsin(x)$, which in `R` is found by using the built in function `asin()`

```{r,fig.width=4,fig.height=3}
# defining pdf of X
pdf_x = Vectorize(function(x){
  if(x>-pi/2 & x<pi/2){cos(x)/2} else 0
})

# showing pdf on plot
ggplot() + geom_function(fun=pdf_x,n=10001) + theme_minimal() + 
  xlim(c(-2.5,2.5)) + ylim(-.5,1) + labs(x='x',y='f(x)')
```

```{r}
# complete the function
rx = function(n){
  # code goes here
  return(-asin(1-2*(runif(n,0,1))))
}

# uncomment the following line of code and check it looks correct
hist(rx(1000))
```

---

## Exercise 3 (15 points): Testing coin flips

In the six sequences below, **only one** of them is actually randomly generated from a fair coin. Use a combination of everything you know (common sense, monte carlo, hypothesis testing, etc.) to identify which is actually random and explain your reasoning.

(***For full points***, conduct a formal test and report a $p$-value for each sequence. You may use a combination of multiple tests to arrive at your answer. If you cannot compute a $p$-value for each sequence, you can still earn a significant amount of partial credit by carefully explaining your reasoning and response as best as you can.)

```{r}
flips1 = "HTHTHTHTHTHTHTHTHTHTHTHTHTHTHTHTHTHTHTHTHTHTHTHTHTHTHTHTHTHTHTHTHTHTHTHTHTHTHTHTHTHTHTHTHTHTHTHTHTHTHTHTHTHTHTHTHTHTHTHTHTHTHTHTHTHTHTHTHTHTHTHTHTHTHTHTHTHTHTHTHTHTHTHTHTHTHTHTHTHTHTHTHTHTHTHTHTHTHTHT"

flips2 = "HHHTHTTTHHTHHTHHHTTTTHTHTHHTTHTHHHTHHTHTTTHTHHHTHTTTHTHTHHTHTHTTHTHHTHTHTTTHTHHHTHTHTTHTHTHHTHTHTHHHTHTTTHTHHTHTHTHHTTTHTHHTHHTTTTHTHTHHHTHTTHTHHTHTHTTHTHHTHTHHHTHHHTHTTTHTTHTTTHTHHHTHTHTTHTHHTHHTHTTT"

flips3 = "HHTHTHTTTHTHHHTHHTTTHTHHTHTTTHTHTHHTHTHTTHTHHHHHHTTTHTHTHHTHTTTHTHHTHTHTTTHTHHHTTHTTTHTHTHHHHTHTTHHTTTTTHTHHHTHTHTTTTTHHHTHHTHHTHHHTTTTHTHTHHHTHHTTTTTHTHHHTHTHTHTTTHTHHHTHTHTHTTHTHHTHTHTHTTTTHTHHHTHTH"

flips4 = "HTHHHHHHHTHTTHHTTHHHTHTHTTTHHTHHHTHHTTHTTTTTTTTTHTHHTTTTTHTHTHTHHTTHTTHTTTTTHHHTHTTTHTHTHHHTHTTTTHTHTHHTTHTHTTHHTHTHHHHTHTTHHTTHTTHTTHTHHHHHHTTTTTTHHHTTHTHHHHTTTHTTHHHTTHTHHTTTHHTHHTTTHTHHTHHHTHHTTHHH"

flips5 = "HHHHHHHHHHTTTTTTTTTTHHHHHHHHHHTTTTTTTTTTHHHHHHHHHHTTTTTTTTTTHHHHHHHHHHTTTTTTTTTTHHHHHHHHHHTTTTTTTTTTHHHHHHHHHHTTTTTTTTTTHHHHHHHHHHTTTTTTTTTTHHHHHHHHHHTTTTTTTTTTHHHHHHHHHHTTTTTTTTTTHHHHHHHHHHTTTTTTTTTT"

flips6 = "TTHTTTHTTTTTTTHTHTHTHTTHTTHTHHTHHTTTHHTHTTTHTHHTHHHTHTTHHTHHTTHTHTTTTHTHTTTHHTTTTTTTTHTHHTTHTTTTTTHTHTHTHTTTHTTHHTTHTTTHHTTTHTTHTTTTHTTTTHHTTTHTHTHHHTTTTTTHTHHTTTTTTTTTTTTHHHTTTHHHTTTHTTTHTHTTHTTTTTHT"

# you can use the function below to split the above sequences in vectors of flips
split = function(str) strsplit(str, split="")[[1]]
split(flips1)
```

Response goes here:

Packages
```{r}
library(dplyr)
library(ggplot2)
```

Longest Run Function
```{r}
longestRun = function(flips){
  # the first flip is always a run of length 1.
  MaxRunSoFar = 1
  currentRun = 1
  
  for(i in 2:length(flips)){ # for every flip
    # if it is equal to the last flip
    if(flips[i]==flips[i-1]){
      # then increase the length of the currentRun
      currentRun = currentRun + 1
      # and if the run is larger than the maxRunSoFar, redefine that.
      if(currentRun>MaxRunSoFar) MaxRunSoFar = currentRun
    }
    # otherwise, 
    if(flips[i]!=flips[i-1]){
      # set the current run back to 1
      currentRun=1
  }
  }
  return(MaxRunSoFar)
}
```

P-value function using 1000, 200 coin flip simulations
```{r}
p_val_run = function(seq,trials){
  
  simulate_S = function(){
    S = sample(c("H","T"), 200,replace=T) %>% longestRun()
    return(S)
  }

  r = trials
  monte_carlo = data.frame(replicate = 1:r, 
                          S = rep(NA,r), 
                           S_in_A = rep(NA, r)) 

  for(i in 1:r){
    monte_carlo$S[i] = simulate_S()
  }
  
  longest_run = longestRun(seq)

  check_if_S_in_A = function(S){
    return(S <= longest_run)
  }

  for(i in 1:r){
   monte_carlo$S_in_A[i] = check_if_S_in_A(monte_carlo$S[i])
 
  }

  monte_carlo = as_tibble(monte_carlo)
  p_value = monte_carlo %>% summarise(mean(S_in_A))
  return(p_value)
}

```

Using the MC simulation method for longest run defined above, we are able to reject the null hypothesis that each coin flip is independent for flips1, as it has a p_value of approximately 0, and conclude with high confidence that flips1 was is not randomly generated from a fair coin.
```{r}
p_val_run(split(flips1),1000)
```
We are also able to reject the null hypothesis for flips2 by the same method, as it also has a p_value of approximately 0, and conclude with high confidence that flips2 was is not randomly generated from a fair coin.
```{r}
p_val_run(split(flips2),1000)
```
For flips6, we see that it has a value of 70 for "H" and 130 for "T".
```{r}
table(split(flips6))
```
This seems like an unusual number for each, so we will test to see how likely those values are assuming a binomial distribution with a probability of 0.5. The null hypothesis for this is that each coin flip is independent, and we will be checking to see how likely it is that there are less than 70 "H" in 1000 trials of 200 binomial coin flip simulations. Here is a histogram of the number of "H" in those 1000 simulations.
```{r}
simulate_H = function(){
  counts = table(sample(c("H","T"), 200,replace=T))
  return(counts["H"] %>% unname())
}

r = 1000
H_simulations = data.frame(replicate = 1:r, 
                           H = rep(NA,r), 
                           lte_70_H = rep(NA, r)) 

for(i in 1:r){
  H_simulations$H[i] = simulate_H()
}
hist(H_simulations$H)
```
Using a similar process as above, we check how many of the 1000 simulations have less than or equal to 70 "H", and find a p_value of approximately 0, so we can reject the null hypothesis and conclude with high confidence that flips6 was is not randomly generated from a fair coin.
```{r}
check_if_H_lte_70 = function(H){
    return(H  <= 70)
}

for(i in 1:r){
  H_simulations$lte_70_H = check_if_H_lte_70(H_simulations$H)
}

H_simulations = as_tibble(H_simulations)
p_value = H_simulations %>% summarise(mean(lte_70_H))
p_value
```
The code below is to test flips5 for the odds of getting the same result given an initial result, ie an H after an H. The odds ratio is defined as R = HH/HT / TH/TT, and flips5 has an R value of 90, where an R value greater than or less than one indicates correlation between the pairs in the odds ratio. Using a function called p_val_ratios, we can simulate what the R values would be for 1000 randomly generated trials of 200 fair coins. Then by computing the mean of how many of these simulations have R values less than or equal to 90, we are given a p-value of approximately 0. We may then conclude with high confidence that there is a higher chance to get the same flip result given an intial result, meaning that these coin flips are likely not random.
```{r}
# install the runner package if necessary
if(!"runner" %in% rownames(installed.packages())) install.packages("runner")

# define function for tabulating consecutive pairs
tableOfPairs = function(vec){
  return(table(runner::runner(vec,k=2,f=paste,collapse="")[-1]))
}

ratioFromTable = function(tb){ #odds of getting heads if you previously got heads vs odds of getting heads if you previously got tails
  return(setNames((tb["HH"]/tb["HT"])/(tb["TH"]/tb["TT"]),"R"))
}

simulate_R = function(){
  S = sample(c("H","T"), 200,replace=T)
  table = tableOfPairs(S)
  return(ratioFromTable(table))
}
  
p_val_ratios = function(trials,ratio){
  r = trials
  monte_carlo = data.frame(replicate = 1:r, 
                          R = rep(NA,r), 
                          R_in_A = rep(NA, r)) 

  for(i in 1:r){
    monte_carlo$R[i] = simulate_R()
  }
  
  check_if_R_in_A = function(S){
    return(S >= ratio)
  }

  for(i in 1:r){
   monte_carlo$R_in_A[i] = check_if_R_in_A(monte_carlo$R[i])
 
  }
  monte_carlo = as_tibble(monte_carlo)
  p_value = monte_carlo %>% summarise(mean(R_in_A))
  return(p_value)
}


flips5_ratio = ratioFromTable(tableOfPairs(split(flips5)))
mc_ratios = p_val_ratios(1000,flips5_ratio)
mc_ratios
```


